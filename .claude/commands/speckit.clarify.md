---
description: 現在の機能仕様の未定義領域を最大5つの高精度な確認質問で特定し、回答を仕様書に反映する。
handoffs:
  - label: 技術計画を作成
    agent: speckit.plan
    prompt: 仕様書の計画を作成してください。使用する技術スタックは...
---

## ユーザー入力

```text
$ARGUMENTS
```

ユーザー入力が空でなければ、**必ず**内容を考慮してから進めること。

## 概要

目的: アクティブな機能仕様の曖昧さや未決定事項を検出・削減し、確認事項を仕様ファイルに直接記録する。

注意: この確認ワークフローは `/speckit.plan` を呼び出す**前**に実行（および完了）されることを想定している。ユーザーが明示的に確認のスキップを宣言した場合（例: 探索的スパイク）は続行してよいが、下流での手戻りリスクが増大することを警告すること。

実行ステップ：

1. リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --paths-only` を**1回**実行する（結合 `--json --paths-only` モード / `-Json -PathsOnly`）。最小限のJSONペイロードフィールドを解析：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （オプションで `IMPL_PLAN`、`TASKS` も後続のチェインフローのために取得。）
   - JSON解析に失敗した場合は中断し、`/speckit.specify` の再実行または機能ブランチ環境の確認をユーザーに指示する。
   - 引数にシングルクォートを含む場合（例: "I'm Groot"）はエスケープ構文を使用: 例 'I'\''m Groot'（またはダブルクォート: "I'm Groot"）。

2. 現在の仕様ファイルを読み込む。以下の分類法を使用した構造化された曖昧性&カバレッジスキャンを実行する。各カテゴリのステータスを判定: 明確 / 部分的 / 欠落。優先度付けに使用する内部カバレッジマップを作成する（質問がない場合を除き、生のマップは出力しない）。

   機能スコープと動作：
   - コアユーザー目標と成功基準
   - 明示的なスコープ外宣言
   - ユーザーロール/ペルソナの区別

   ドメインとデータモデル：
   - エンティティ、属性、リレーション
   - アイデンティティと一意性ルール
   - ライフサイクル/状態遷移
   - データ量/スケールの前提

   インタラクションとUXフロー：
   - 重要なユーザージャーニー/シーケンス
   - エラー/空/読込中の状態
   - アクセシビリティやローカライゼーションの注意事項

   非機能品質属性：
   - パフォーマンス（レイテンシ、スループット目標）
   - スケーラビリティ（水平/垂直、上限）
   - 信頼性と可用性（稼働率、復旧期待値）
   - 可観測性（ログ、メトリクス、トレーシングシグナル）
   - セキュリティとプライバシー（認証/認可、データ保護、脅威の前提）
   - コンプライアンス/規制制約（該当する場合）

   統合と外部依存：
   - 外部サービス/APIとその障害モード
   - データインポート/エクスポート形式
   - プロトコル/バージョニングの前提

   エッジケースと障害処理：
   - ネガティブシナリオ
   - レート制限/スロットリング
   - 競合解決（例: 同時編集）

   制約とトレードオフ：
   - 技術的制約（言語、ストレージ、ホスティング）
   - 明示的なトレードオフや却下された代替案

   用語と整合性：
   - 正規化された用語集
   - 回避すべき同義語/非推奨用語

   完了シグナル：
   - 受け入れ基準のテスト可能性
   - 測定可能なDefinition of Doneスタイルの指標

   その他/プレースホルダー：
   - TODOマーカー/未解決の決定
   - 定量化されていない曖昧な形容詞（"堅牢"、"直感的"）

   部分的または欠落ステータスの各カテゴリについて、以下の場合を除き候補質問を追加：
   - 確認しても実装や検証戦略に実質的な影響がない
   - 情報が計画フェーズに委ねた方がよい（内部的にメモ）

3. 候補確認質問の優先度付きキュー（最大5つ）を内部で生成する。全てを一度に出力しない。以下の制約を適用：
    - セッション全体で最大10問。
    - 各質問は以下のいずれかで回答可能であること：
       - 短い選択式（2-5個の明確で排他的なオプション）、または
       - 一語/短いフレーズ（明示的に制約: "5語以内で回答"）。
    - アーキテクチャ、データモデリング、タスク分解、テスト設計、UX動作、運用準備、コンプライアンス検証に実質的に影響する質問のみ含める。
    - カテゴリカバレッジのバランスを確保: 影響の大きい未解決カテゴリを優先。低影響の質問を2つ出すより、単一の高影響領域（例: セキュリティ態勢）の未解決を優先。
    - 既に回答済み、些細なスタイル好み、計画レベルの実行詳細（正確性をブロックしない限り）を除外。
    - 下流の手戻りリスクを削減する、または不整合な受け入れテストを防ぐ確認を優先。
    - 5カテゴリ以上が未解決の場合は、（影響度 × 不確実度）ヒューリスティックで上位5つを選択。

4. 順次質問ループ（インタラクティブ）：
    - **1回に1つだけ**質問を提示する。
    - 選択式質問の場合：
       - **全オプションを分析**し、以下に基づいて**最適なオプション**を判定：
          - プロジェクトタイプのベストプラクティス
          - 類似実装の一般的なパターン
          - リスク削減（セキュリティ、パフォーマンス、保守性）
          - 仕様に見える明示的なプロジェクト目標や制約との整合
       - **推奨オプションを目立つように先頭に提示**し、明確な根拠（1-2文で最適な理由を説明）を付ける。
       - 形式: `**推奨:** オプション [X] - <根拠>`
       - その後、全オプションをMarkdownテーブルで表示：

       | オプション | 説明 |
       |-----------|------|
       | A | <オプションA の説明> |
       | B | <オプションB の説明> |
       | C | <オプションC の説明>（必要に応じてD/Eを追加、最大5つ） |
       | 短文 | 別の短い回答を提供（5語以内）（自由回答が適切な場合のみ含む） |

       - テーブルの後に追記: `オプション文字で回答（例: "A"）、推奨を受け入れる場合は「はい」や「推奨」、または独自の短い回答を提供できます。`
    - 短文回答形式の場合（意味のある選択肢がない場合）：
       - ベストプラクティスとコンテキストに基づいた**提案回答**を提供。
       - 形式: `**提案:** <提案する回答> - <簡潔な根拠>`
       - その後出力: `形式: 短い回答（5語以内）。提案を受け入れる場合は「はい」や「提案」、または独自の回答を提供できます。`
    - ユーザーの回答後：
       - ユーザーが「はい」「推奨」「提案」と返答した場合は、先に述べた推奨/提案を回答として使用。
       - それ以外は、回答がオプションにマッピングされるか、5語以内の制約に収まるか検証。
       - 曖昧な場合は簡潔な確認を求める（同じ質問のカウントに含む。次に進まない）。
       - 満足のいく回答が得られたら、ワーキングメモリに記録（まだディスクには書き込まない）し、キューの次の質問に進む。
    - 以下の場合に追加質問を停止：
       - 全ての重要な曖昧性が早期に解決された場合（残りのキューが不要に）、または
       - ユーザーが完了を示した場合（"完了"、"OK"、"もう十分"）、または
       - 5問に達した場合。
    - 今後のキューにある質問を事前に公開しない。
    - 開始時に有効な質問がない場合は、重要な曖昧性なしと即座にレポート。

5. 受け入れた各回答後の統合（インクリメンタル更新アプローチ）：
    - 仕様のインメモリ表現（開始時に1回読み込み）と生のファイル内容を維持。
    - このセッションで最初に統合する回答について：
       - `## 確認事項` セクションが存在することを確認（欠落している場合は仕様テンプレートの最上位コンテキスト/概要セクションの直後に作成）。
       - その下に（存在しない場合）本日の `### セッション YYYY-MM-DD` サブ見出しを作成。
    - 受け入れ直後にバレットラインを追加: `- Q: <質問> → A: <最終回答>`。
    - その後、最も適切なセクションに即座に確認内容を適用：
       - 機能的な曖昧性 → 機能要件のバレットを更新または追加。
       - ユーザーインタラクション/アクターの区別 → ユーザーストーリーまたはアクターサブセクション（存在する場合）を確認されたロール、制約、シナリオで更新。
       - データの形状/エンティティ → データモデルを更新（フィールド、型、リレーションを追加）、順序を保持。追加された制約を簡潔にメモ。
       - 非機能制約 → 非機能/品質属性セクションに測定可能な基準を追加/修正（曖昧な形容詞をメトリクスまたは明示的な目標に変換）。
       - エッジケース/ネガティブフロー → エッジケース/エラーハンドリングに新しいバレットを追加（テンプレートにプレースホルダーがある場合はそのサブセクションを作成）。
       - 用語の競合 → 仕様全体で用語を正規化。必要な場合のみ元の用語を `（以前は"X"と呼ばれていた）` として1回保持。
    - 確認により以前の曖昧な記述が無効になる場合は、重複ではなくその記述を置換。古い矛盾するテキストを残さない。
    - 各統合後に仕様ファイルを保存し、コンテキスト喪失リスクを最小化（アトミック上書き）。
    - フォーマットの保持: 無関係なセクションを並べ替えない。見出し階層を維持。
    - 挿入される各確認事項は最小限でテスト可能にする（説明的な文章の肥大化を避ける）。

6. 検証（各書き込み後 + 最終パスで実行）：
   - 確認事項セッションに受け入れた回答ごとに正確に1つのバレットがある（重複なし）。
   - 質問（受け入れ済み）の合計 ≤ 5。
   - 更新されたセクションに、新しい回答で解決されるべき曖昧なプレースホルダーが残っていない。
   - 矛盾する以前の記述が残っていない（無効になった代替選択肢を削除したかスキャン）。
   - Markdown構造が有効。許可される新しい見出し: `## 確認事項`、`### セッション YYYY-MM-DD` のみ。
   - 用語の整合性: 更新された全セクションで同じ正規化された用語を使用。

7. 更新された仕様を `FEATURE_SPEC` に書き戻す。

8. 完了レポート（質問ループ終了時または早期終了後）：
   - 質問した数と回答した数。
   - 更新された仕様のパス。
   - 変更されたセクション（名前をリスト）。
   - 各分類カテゴリのステータスを示すカバレッジサマリーテーブル: 解決済み（部分的/欠落だったが対応済み）、延期（質問枠超過または計画フェーズに適した）、明確（既に十分）、未解決（まだ部分的/欠落だが低影響）。
   - 未解決または延期が残っている場合は、`/speckit.plan` に進むか、計画後に `/speckit.clarify` を再実行するか推奨。
   - 推奨する次のコマンド。

動作ルール：

- 意味のある曖昧性が見つからない場合（または全ての候補質問が低影響の場合）は: 「正式な確認が必要な重要な曖昧性は検出されませんでした。」と回答し、次のステップへの進行を提案。
- 仕様ファイルが欠落している場合は、まず `/speckit.specify` の実行をユーザーに指示する（ここで新規仕様を作成しない）。
- 質問の合計は5問を超えない（1つの質問のリトライは新しい質問としてカウントしない）。
- 機能的な明確さをブロックしない限り、投機的な技術スタックの質問は避ける。
- ユーザーの早期終了シグナルを尊重する（"ストップ"、"完了"、"進めて"）。
- 完全なカバレッジにより質問がない場合は、コンパクトなカバレッジサマリー（全カテゴリ「明確」）を出力し、次のステップへの進行を提案。
- 質問枠に達しても高影響の未解決カテゴリが残っている場合は、根拠付きで「延期」として明示的にフラグ。

優先度付けのコンテキスト: $ARGUMENTS
