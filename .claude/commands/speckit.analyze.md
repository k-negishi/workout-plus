---
description: spec.md、plan.md、tasks.md の横断的な整合性・品質分析を非破壊で実行する。タスク生成後に使用。
---

## ユーザー入力

```text
$ARGUMENTS
```

ユーザー入力が空でなければ、**必ず**内容を考慮してから進めること。

## 目的

実装前に、3つのコアアーティファクト（`spec.md`、`plan.md`、`tasks.md`）間の不整合、重複、曖昧さ、未定義項目を特定する。このコマンドは `/speckit.tasks` が `tasks.md` を正常に生成した**後**にのみ実行すること。

## 動作制約

**厳密に読み取り専用**: ファイルを**一切変更しない**。構造化された分析レポートを出力する。オプションで修正案を提示する（ユーザーが明示的に承認するまで編集コマンドは実行しない）。

**コンスティテューション権限**: プロジェクトコンスティテューション（`.specify/memory/constitution.md`）はこの分析範囲内で**交渉不可**。コンスティテューションとの矛盾は自動的にCRITICALとなり、仕様・計画・タスク側の調整が必要 — 原則の希薄化、再解釈、無視は不可。原則自体の変更が必要な場合は `/speckit.analyze` の外で別途明示的にコンスティテューション更新を行うこと。

## 実行ステップ

### 1. 分析コンテキストの初期化

リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` を1回実行し、JSONからFEATURE_DIRとAVAILABLE_DOCSを解析する。絶対パスを導出：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

必要なファイルが欠けている場合はエラーメッセージで中断し、不足している前提コマンドの実行を指示する。
引数にシングルクォートを含む場合（例: "I'm Groot"）はエスケープ構文を使用: 例 'I'\''m Groot'（またはダブルクォート: "I'm Groot"）。

### 2. アーティファクトの読み込み（段階的開示）

各アーティファクトから必要最小限のコンテキストのみ読み込む：

**spec.mdから:**

- 概要/コンテキスト
- 機能要件
- 非機能要件
- ユーザーストーリー
- エッジケース（存在する場合）

**plan.mdから:**

- アーキテクチャ/技術スタック選定
- データモデル参照
- フェーズ
- 技術的制約

**tasks.mdから:**

- タスクID
- 説明
- フェーズ分類
- 並列マーカー [P]
- 参照ファイルパス

**コンスティテューションから:**

- `.specify/memory/constitution.md` を原則検証のために読み込む

### 3. セマンティックモデルの構築

内部表現を作成する（生のアーティファクトは出力に含めない）：

- **要件インベントリ**: 各機能要件 + 非機能要件に安定したキーを付与（命令形フレーズからスラグを導出。例: "ユーザーがファイルをアップロードできる" → `user-can-upload-file`）
- **ユーザーストーリー/アクションインベントリ**: 受け入れ基準を持つ個別のユーザーアクション
- **タスクカバレッジマッピング**: 各タスクを1つ以上の要件またはストーリーにマッピング（キーワード/明示的参照パターンによる推論）
- **コンスティテューションルールセット**: 原則名とMUST/SHOULD規範文を抽出

### 4. 検出パス（トークン効率的な分析）

高シグナルの所見に集中する。所見は最大50件に制限し、残りはオーバーフローサマリーに集約する。

#### A. 重複検出

- ほぼ重複する要件を特定
- 品質の低い表現を統合対象としてマーク

#### B. 曖昧性検出

- 測定可能な基準を欠く曖昧な形容詞（高速、スケーラブル、安全、直感的、堅牢）をフラグ
- 未解決のプレースホルダー（TODO、TKTK、???、`<placeholder>` 等）をフラグ

#### C. 未定義の検出

- 動詞はあるがオブジェクトや測定可能な成果が欠けている要件
- 受け入れ基準との整合が取れていないユーザーストーリー
- 仕様/計画に定義されていないファイルやコンポーネントを参照するタスク

#### D. コンスティテューション整合性

- MUST原則に違反する要件または計画要素
- コンスティテューションが義務付けるセクションや品質ゲートの欠落

#### E. カバレッジギャップ

- 関連タスクがゼロの要件
- マッピングされた要件/ストーリーがないタスク
- タスクに反映されていない非機能要件（例: パフォーマンス、セキュリティ）

#### F. 不整合

- 用語のドリフト（同じ概念がファイル間で異なる名前）
- 計画で参照されているが仕様に存在しないデータエンティティ（またはその逆）
- タスクの順序矛盾（例: 依存関係の注記なしに基盤セットアップタスクより前に統合タスクがある）
- 矛盾する要件（例: 一方はNext.jsを要求し、他方はVueを指定）

### 5. 重大度の割り当て

以下のヒューリスティックで所見を優先度付け：

- **CRITICAL**: コンスティテューションのMUSTに違反、コア仕様アーティファクトの欠落、またはベースライン機能をブロックするカバレッジゼロの要件
- **HIGH**: 重複・矛盾する要件、曖昧なセキュリティ/パフォーマンス属性、テスト不能な受け入れ基準
- **MEDIUM**: 用語のドリフト、非機能タスクカバレッジの欠落、未定義のエッジケース
- **LOW**: スタイル/表現の改善、実行順序に影響しない軽微な冗長性

### 6. コンパクトな分析レポートの作成

以下の構造でMarkdownレポートを出力する（ファイル書き込みなし）：

## 仕様分析レポート

| ID | カテゴリ | 重大度 | 場所 | 概要 | 推奨 |
|----|---------|--------|------|------|------|
| A1 | 重複 | HIGH | spec.md:L120-134 | 2つの類似要件が ... | 表現を統合し、より明確な方を残す |

（所見ごとに1行追加。カテゴリ頭文字をプレフィックスとした安定IDを生成。）

**カバレッジサマリーテーブル:**

| 要件キー | タスクあり? | タスクID | 備考 |
|----------|-----------|---------|------|

**コンスティテューション整合性の問題:** （該当する場合）

**マッピングされていないタスク:** （該当する場合）

**メトリクス:**

- 要件総数
- タスク総数
- カバレッジ %（1つ以上のタスクを持つ要件）
- 曖昧性の数
- 重複の数
- CRITICALイシューの数

### 7. 次のアクションの提示

レポートの最後に、簡潔な「次のアクション」ブロックを出力：

- CRITICALイシューが存在する場合: `/speckit.implement` の前に解決を推奨
- LOW/MEDIUMのみの場合: 進行可能だが改善提案を提示
- 明示的なコマンド提案を提示: 例「/speckit.specify で仕様を改善」「/speckit.plan でアーキテクチャを調整」「tasks.md を手動編集して 'performance-metrics' のカバレッジを追加」

### 8. 修正案の提示

ユーザーに確認: 「上位N件の問題について具体的な修正案を提案しますか？」（自動適用は**しない**。）

## 動作原則

### コンテキスト効率

- **必要最小限の高シグナルトークン**: 網羅的なドキュメントではなくアクション可能な所見に集中
- **段階的開示**: アーティファクトを段階的に読み込み、全内容を分析にダンプしない
- **トークン効率的な出力**: 所見テーブルを50行に制限し、オーバーフローを要約
- **決定論的な結果**: 変更なしで再実行した場合、一貫したIDとカウントを生成

### 分析ガイドライン

- **ファイルを一切変更しない**（読み取り専用分析）
- **欠落セクションを捏造しない**（存在しない場合は正確に報告）
- **コンスティテューション違反を最優先**（常にCRITICAL）
- **網羅的なルールより具体例を使用**（汎用パターンではなく具体的なインスタンスを引用）
- **問題ゼロの場合も適切にレポート**（カバレッジ統計付きの成功レポートを出力）

## コンテキスト

$ARGUMENTS
