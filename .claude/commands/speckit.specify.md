---
description: 自然言語の機能説明から機能仕様書を作成・更新する。
handoffs:
  - label: 技術計画を作成
    agent: speckit.plan
    prompt: 仕様書の計画を作成してください。使用する技術スタックは...
  - label: 仕様の要件を明確化
    agent: speckit.clarify
    prompt: 仕様要件を明確化してください
    send: true
---

## ユーザー入力

```text
$ARGUMENTS
```

ユーザー入力が空でなければ、**必ず**内容を考慮してから進めること。

## 概要

ユーザーが `/speckit.specify` の後に入力したテキストが機能説明である。`$ARGUMENTS` がそのまま表示されていても、この会話で常に利用可能であると仮定する。ユーザーが空のコマンドを送った場合のみ再入力を求めること。

その機能説明に基づき、以下を実行：

1. **ブランチ用の簡潔なショートネームを生成**（2-4語）：
   - 機能説明を分析し、最も意味のあるキーワードを抽出
   - 機能の本質を捉えた2-4語のショートネームを作成
   - 可能な場合はアクション-名詞形式を使用（例: "add-user-auth", "fix-payment-bug"）
   - 技術用語やアクロニムを保持（OAuth2, API, JWT 等）
   - 機能が一目で理解できる程度に簡潔だが説明的に
   - 例：
     - "ユーザー認証を追加したい" → "user-auth"
     - "APIにOAuth2統合を実装" → "oauth2-api-integration"
     - "アナリティクスダッシュボードを作成" → "analytics-dashboard"
     - "決済処理のタイムアウトバグを修正" → "fix-payment-timeout"

2. **新規作成前に既存ブランチを確認**：

   a. まず全リモートブランチをフェッチして最新情報を取得：

      ```bash
      git fetch --all --prune
      ```

   b. ショートネームに対する全ソースの最大フィーチャー番号を検索：
      - リモートブランチ: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - ローカルブランチ: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - specsディレクトリ: `specs/[0-9]+-<short-name>` にマッチするディレクトリを確認

   c. 次の利用可能な番号を決定：
      - 3つのソース全てから全ての番号を抽出
      - 最大番号 N を特定
      - 新しいブランチ番号に N+1 を使用

   d. 算出した番号とショートネームでスクリプト `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` を実行：
      - `--number N+1` と `--short-name "your-short-name"` を機能説明と共に渡す
      - Bash例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell例: `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**：
   - 3つのソース全て（リモートブランチ、ローカルブランチ、specsディレクトリ）で最大番号を確認
   - 正確なショートネームパターンのブランチ/ディレクトリのみマッチ
   - このショートネームで既存のブランチ/ディレクトリが見つからない場合は番号1から開始
   - このスクリプトは1つの機能につき1回のみ実行すること
   - JSONはターミナル出力として提供される — 常に参照して実際のコンテンツを取得すること
   - JSON出力にはBRANCH_NAMEとSPEC_FILEパスが含まれる
   - 引数にシングルクォートを含む場合（例: "I'm Groot"）はエスケープ構文を使用: 例 'I'\''m Groot'（またはダブルクォート: "I'm Groot"）

3. `.specify/templates/spec-template.md` を読み込み、必要なセクションを理解する。

4. 以下の実行フローに従う：

    1. 入力からユーザーの説明を解析
       空の場合: ERROR "機能説明が提供されていません"
    2. 説明からキーコンセプトを抽出
       特定: アクター、アクション、データ、制約
    3. 不明確な側面について：
       - コンテキストと業界標準に基づいて合理的な推測を行う
       - 以下の場合のみ [要確認: 具体的な質問] とマーク：
         - 選択が機能のスコープやユーザー体験に大きく影響する場合
         - 異なる含意を持つ複数の合理的な解釈が存在する場合
         - 合理的なデフォルトが存在しない場合
       - **上限: [要確認] マーカーは合計最大3つ**
       - 確認の優先度: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術的詳細
    4. ユーザーシナリオ&テストセクションを記入
       明確なユーザーフローがない場合: ERROR "ユーザーシナリオを判定できません"
    5. 機能要件を生成
       各要件はテスト可能であること
       未指定の詳細には合理的なデフォルトを使用（前提条件セクションに仮定を文書化）
    6. 成功基準を定義
       測定可能で技術非依存の成果を作成
       定量的メトリクス（時間、パフォーマンス、ボリューム）と定性的指標（ユーザー満足度、タスク完了率）の両方を含める
       各基準は実装詳細なしで検証可能であること
    7. キーエンティティを特定（データが関与する場合）
    8. 返却: SUCCESS（仕様は計画準備完了）

5. テンプレート構造を使用して仕様をSPEC_FILEに書き込む。プレースホルダーを機能説明（引数）から導出した具体的な詳細に置換しつつ、セクションの順序と見出しを保持する。

6. **仕様品質の検証**: 初期仕様を書いた後、品質基準に対して検証する：

   a. **仕様品質チェックリストを作成**: 以下の検証項目でチェックリストファイルを `FEATURE_DIR/checklists/requirements.md` に生成：

      ```markdown
      # 仕様品質チェックリスト: [機能名]

      **目的**: 計画フェーズに進む前に仕様の完全性と品質を検証する
      **作成日**: [日付]
      **機能**: [spec.mdへのリンク]

      ## コンテンツ品質

      - [ ] 実装詳細なし（言語、フレームワーク、API）
      - [ ] ユーザー価値とビジネスニーズに焦点
      - [ ] 非技術ステークホルダー向けに記述
      - [ ] 全必須セクション完了

      ## 要件の完全性

      - [ ] [要確認] マーカーが残っていない
      - [ ] 要件がテスト可能で曖昧でない
      - [ ] 成功基準が測定可能
      - [ ] 成功基準が技術非依存（実装詳細なし）
      - [ ] 全受け入れシナリオが定義済み
      - [ ] エッジケースが特定済み
      - [ ] スコープが明確に境界付け済み
      - [ ] 依存関係と前提条件が特定済み

      ## 機能の準備状態

      - [ ] 全機能要件に明確な受け入れ基準あり
      - [ ] ユーザーシナリオが主要フローをカバー
      - [ ] 機能が成功基準で定義された測定可能な成果を満たす
      - [ ] 実装詳細が仕様に漏れていない

      ## メモ

      - 未完了とマークされた項目は `/speckit.clarify` または `/speckit.plan` の前に仕様の更新が必要
      ```

   b. **検証チェックの実行**: 各チェックリスト項目に対して仕様をレビュー：
      - 各項目について合格/不合格を判定
      - 発見された具体的な問題を文書化（関連する仕様セクションを引用）

   c. **検証結果の処理**：

      - **全項目合格の場合**: チェックリストを完了としてマークし、ステップ6に進む

      - **項目が不合格の場合（[要確認] を除く）**：
        1. 不合格項目と具体的な問題をリスト
        2. 各問題に対応するよう仕様を更新
        3. 全項目が合格するまで検証を再実行（最大3回）
        4. 3回の反復後もまだ不合格の場合はチェックリストのメモに残存問題を文書化しユーザーに警告

      - **[要確認] マーカーが残っている場合**：
        1. 仕様から全ての [要確認: ...] マーカーを抽出
        2. **上限チェック**: 3つ以上のマーカーが存在する場合、最も重要な3つのみ保持（スコープ/セキュリティ/UXの影響順）し、残りは合理的に推測
        3. 確認が必要な各項目（最大3つ）について以下の形式でユーザーに選択肢を提示：

           ```markdown
           ## 質問 [N]: [トピック]

           **コンテキスト**: [関連する仕様セクションを引用]

           **確認事項**: [要確認マーカーからの具体的な質問]

           **選択肢**:

           | オプション | 回答 | 影響 |
           |-----------|------|------|
           | A         | [第一候補] | [機能への影響] |
           | B         | [第二候補] | [機能への影響] |
           | C         | [第三候補] | [機能への影響] |
           | カスタム   | 独自の回答を入力 | [カスタム入力の説明] |

           **あなたの選択**: _[ユーザーの回答を待つ]_
           ```

        4. **重要 - テーブルフォーマット**: Markdownテーブルが正しくフォーマットされていることを確認：
           - パイプの整列と一貫したスペース: `| コンテンツ |`（`|コンテンツ|` ではない）
           - ヘッダーセパレーターは最低3つのダッシュ: `|--------|`
           - Markdownプレビューでテーブルが正しくレンダリングされることをテスト
        5. 質問は連番（Q1、Q2、Q3 — 最大3つ）
        6. 回答を待つ前に全質問をまとめて提示
        7. ユーザーの全質問への回答を待つ（例: "Q1: A, Q2: カスタム - [詳細], Q3: B"）
        8. 各 [要確認] マーカーをユーザーが選択/提供した回答で置換して仕様を更新
        9. 全確認事項解決後に検証を再実行

   d. **チェックリストの更新**: 各検証反復後にチェックリストファイルの合格/不合格ステータスを更新

7. ブランチ名、仕様ファイルパス、チェックリスト結果、次フェーズ（`/speckit.clarify` または `/speckit.plan`）への準備状態を報告して完了。

**注意:** スクリプトは仕様ファイルの書き込み前に新ブランチを作成・チェックアウトし、仕様ファイルを初期化する。

## 一般ガイドライン

## クイックガイドライン

- ユーザーが**何を**必要とし、**なぜ**必要かに焦点を当てる。
- 実装方法は避ける（技術スタック、API、コード構造は記載しない）。
- ビジネスステークホルダー向けに記述し、開発者向けではない。
- 仕様書に埋め込まれたチェックリストは作成しない。それは別コマンドで行う。

### セクション要件

- **必須セクション**: 全機能で必ず完了させる
- **オプションセクション**: 機能に関連する場合のみ含める
- セクションが該当しない場合は完全に削除する（"N/A" のまま残さない）

### AI生成時の注意

このユーザープロンプトから仕様を生成する際：

1. **合理的な推測を行う**: コンテキスト、業界標準、一般的なパターンを使用してギャップを埋める
2. **前提条件を文書化する**: 前提条件セクションに合理的なデフォルトを記録
3. **確認事項を制限する**: [要確認] マーカーは最大3つ — 以下の重要な決定にのみ使用：
   - 機能のスコープやユーザー体験に大きく影響する
   - 異なる含意を持つ複数の合理的な解釈がある
   - 合理的なデフォルトが存在しない
4. **確認の優先度**: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術的詳細
5. **テスターのように考える**: 曖昧な要件はすべて「テスト可能で曖昧でない」チェック項目に不合格となるべき
6. **確認が一般的に必要な領域**（合理的なデフォルトがない場合のみ）：
   - 機能のスコープと境界（特定のユースケースの含む/除外）
   - ユーザータイプと権限（複数の矛盾する解釈が可能な場合）
   - セキュリティ/コンプライアンス要件（法的/財務的に重要な場合）

**合理的なデフォルトの例**（これらについては質問しない）：

- データ保持: ドメインの業界標準に従う
- パフォーマンス目標: 特に指定がない限りWeb/モバイルアプリの標準的な期待値
- エラーハンドリング: 適切なフォールバック付きのユーザーフレンドリーなメッセージ
- 認証方法: Webアプリの標準的なセッションベースまたはOAuth2
- 統合パターン: 特に指定がない限りRESTful API

### 成功基準ガイドライン

成功基準は以下を満たすこと：

1. **測定可能**: 具体的なメトリクスを含む（時間、パーセンテージ、件数、レート）
2. **技術非依存**: フレームワーク、言語、データベース、ツールへの言及なし
3. **ユーザー中心**: システム内部ではなく、ユーザー/ビジネス視点での成果を記述
4. **検証可能**: 実装詳細を知らなくてもテスト/検証可能

**良い例**：

- "ユーザーが3分以内にチェックアウトを完了できる"
- "システムが10,000の同時ユーザーをサポートする"
- "検索の95%が1秒以内に結果を返す"
- "タスク完了率が40%向上する"

**悪い例**（実装中心）：

- "APIレスポンスタイムが200ms以下"（技術的すぎる。"ユーザーが即座に結果を確認できる" を使用）
- "データベースが1000 TPSを処理できる"（実装詳細。ユーザー向けメトリクスを使用）
- "Reactコンポーネントが効率的にレンダリングされる"（フレームワーク固有）
- "Redisキャッシュヒット率が80%以上"（技術固有）
