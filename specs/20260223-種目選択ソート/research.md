# Research: 種目選択ソート

## 決定 1: ソート状態の保持場所

**決定**: Zustand の `exerciseStore` に `sortOrder` フィールドを追加してセッション内保持する。

**根拠**:
- AsyncStorage + 独立ストアでは永続化が必要になり、オーバーエンジニアリング
- `exerciseStore` は既にセッション内の種目キャッシュを管理しており、ソート状態も同一コンテキスト
- セッションリセット（アプリ再起動）でデフォルト（名前順）に戻る挙動が自然

**検討した代替案**:
- AsyncStorage 永続化: ユーザーが毎回同じソートを使う場合に便利だが、過剰。FR-008 はセッション内保持で十分
- 別ストア（uiPreferencesStore）: 独立性は高いが、exerciseStore との密結合が避けられないため分離コストに見合わない

---

## 決定 2: 「よく使う順」の使用回数算出方法

**決定**: ExerciseRepository に `findAllWithUsageCount()` クエリを追加し、`workout_exercises` テーブルを LEFT JOIN で集計する。

```sql
SELECT
  e.*,
  COUNT(we.exercise_id) AS usage_count
FROM exercises e
LEFT JOIN workout_exercises we ON e.id = we.exercise_id
GROUP BY e.id
ORDER BY usage_count DESC, e.name ASC
```

**根拠**:
- 既存スキーマで実現可能（`workout_exercises.exercise_id` が外部キーで使用履歴を持つ）
- 集計はDB層で行うことでJS側のメモリコストを削減
- 使用履歴0件の種目は `COUNT = 0` → 名前順フォールバック（ORDER BY usage_count DESC, name ASC で自然に実現）

**検討した代替案**:
- JS側で集計: 全 workout_exercises を取得して JS でカウント → データ量が多いと遅延が生じる
- exercises テーブルに `usage_count` カラム追加: スキーマ変更が必要、更新タイミングの同期が困難

---

## 決定 3: ソートUIのデザイン

**決定**: 水平スクロール可能なチップ（Chip/Tag）形式のソートセレクター。画面上部・検索バーの下に配置。

```
[名前順] [部位別] [追加日順] [よく使う順]
```

**根拠**:
- 引き算のデザイン原則（Constitution II）に沿い、最小限の視覚的存在感
- チップ形式は選択状態（active/inactive）の視覚的区別が明確
- 水平スクロールにより全オプション4つが画面幅を取らずに収まる
- Dropdownより操作ステップが少ない（1タップで切替）

**検討した代替案**:
- ドロップダウン（ActionSheet/Modal）: タップ数が増える（2ステップ）
- アイコンボタン群: ソート内容がわかりにくい
- セグメントコントロール: 4つになると文字が小さくなりすぎる

---

## 決定 4: 「部位別」ソート時の既存セクション表示

**決定**: 「部位別」選択時はお気に入り・マイ種目セクションを廃止し、すべての種目を部位グループに統合する。

**根拠**:
- 部位別ソートの目的は「部位でグループを確認したい」であり、お気に入りを分離する意味がない
- 実装がシンプルになる（条件分岐を減らせる）
- エッジケース（User Story 3, Acceptance Scenario 2）に明記済み

---

## 決定 5: 「追加日順」の対象

**決定**: `exercises.created_at`（UNIX ミリ秒）の降順でソートし、セクション分けなし（フラットリスト）。

**根拠**:
- プリセット種目はすべて同一日時（シード時）に作成されるため、実質「カスタム種目が先頭に来る」挙動になる
- セクション分けなしのフラットリストが最もシンプルで実装コストが低い
- カスタム種目をまとめて確認したいユーザーのニーズに合致

---

## 未解決事項

なし。すべての技術的な疑問点が既存コードの調査と上記決定で解消された。
